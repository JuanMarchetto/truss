//! YAML parsing using tree-sitter.
//! Provides incremental parsing capabilities.

use tree_sitter::{Language, Parser, Tree};
use tree_sitter_yaml as ts_yaml;

/// Convert tree-sitter-yaml's `LanguageFn` to a `Language`.
///
/// tree-sitter 0.21's `LanguageFn` exposes a raw C function pointer that must
/// be called through FFI to obtain the language grammar. This wrapper
/// encapsulates that call so the rest of the crate remains safe.
fn language_from_fn() -> Language {
    let lang_fn = ts_yaml::LANGUAGE.into_raw();
    // SAFETY: `lang_fn` is the C entry point generated by tree-sitter for
    // the YAML grammar. It returns a valid `*const TSLanguage` whose layout
    // matches what `Language::from_raw` expects. The pointer is non-null and
    // lives for the duration of the program (static data in the compiled
    // grammar). The `as *const _` cast converts `*mut` to `*const`, which
    // is safe because we never write through this pointer.
    unsafe {
        let raw_ptr = lang_fn();
        Language::from_raw(raw_ptr as *const _)
    }
}

/// YAML parser with incremental parsing support.
pub struct YamlParser {
    parser: Parser,
}

impl YamlParser {
    /// Create a new YAML parser.
    ///
    /// # Panics
    ///
    /// Panics if the compiled-in tree-sitter YAML grammar fails to load.
    /// This should never happen in practice since the grammar is statically
    /// linked at compile time.
    pub fn new() -> Self {
        let mut parser = Parser::new();
        let language = language_from_fn();
        parser
            .set_language(&language)
            .expect("Failed to load tree-sitter YAML grammar â€” this is a build-time bug");

        Self { parser }
    }

    /// Parse YAML source code into a syntax tree.
    ///
    /// This is a full parse. For incremental updates, use `parse_incremental`.
    pub fn parse(&mut self, source: &str) -> Result<Tree, ParseError> {
        self.parser
            .parse(source, None)
            .ok_or(ParseError::ParseFailed)
    }

    /// Parse YAML with an existing tree for incremental updates.
    ///
    /// This allows efficient re-parsing when only part of the document changes.
    /// The old_tree should be from a previous parse of a similar document.
    pub fn parse_incremental(
        &mut self,
        source: &str,
        old_tree: Option<&Tree>,
    ) -> Result<Tree, ParseError> {
        self.parser
            .parse(source, old_tree)
            .ok_or(ParseError::ParseFailed)
    }
}

impl Default for YamlParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse error.
#[derive(Debug, Clone)]
pub enum ParseError {
    ParseFailed,
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ParseError::ParseFailed => write!(f, "Failed to parse YAML"),
        }
    }
}

impl std::error::Error for ParseError {}
